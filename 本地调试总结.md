好的，我来输出一份详细的分析报告，总结这次为什么一开始看不到 [qiankun][dev] 日志、期间遇到的阻碍、以及最终是如何解决并沉淀经验的。

一、背景与目标

- 目标：在主应用示例运行 React 子应用时，能够在浏览器控制台看到我们在本地源码中新增的调试日志（如 [qiankun][dev] 与 666...），以验证代码路径被正确执行、且示例实际消费的是本地构建产物。
- 场景：主应用示例有多条触发路径：
  - 直接在主应用入口调用 qiankun API 的 Vanilla 路径（由 `index.js` 驱动）。
  - 通过 React 绑定组件 MicroApp 的路径（由 `ReactRender.jsx` 驱动）。

二、现象与初始判断（为什么一开始没有这么处理）

- 现象：使用 React 路径加载 react16 子应用时，浏览器中没有出现 [qiankun][dev] 日志。
- 初始判断（导致走了弯路的原因）：
  1. 1.
     认为主应用示例已“直连本地构建产物”。因为 `index.js` 里曾出现过从本地 dist/esm 引用 qiankun 的写法（以及我们看到的调试字符串 666... 存在于 `loadMicroApp.ts` ），误以为 React 路径也同样使用了这份本地产物。
  2. 2.
     忽视了 React 路径和 Vanilla 路径的差异：React 路径经由 `ReactRender.jsx` 使用 @qiankunjs/react 的 MicroApp 组件，这条链路内部在 `index.ts` 再去调用 qiankun 的 API，最终“qiankun”这个包的解析权交给了示例工程的 bundler，而不是主入口 index.js 的直连写法。
  3. 3.
     过度依赖 workspace:* 的心理预期：以为 pnpm workspace 会自然让示例解析到本地源码/构建，但 webpack 实际按模块解析规则走 node_modules/虚拟存储，若不强制 alias，它可能解析到已发布版本或另一份打包副本（没有新加的调试日志）。
   
三、关键排查步骤回顾（时间线）

- 确认引入方式：
  - 搜索 examples/main 的 import/require，发现 Vanilla 路径与 React 路径行为不同。
  - 查看 examples/main 的 package.json，@qiankunjs/react 走 workspace 版本；查看 `index.ts` ，证实 React 绑定内部会调用 qiankun 的 loadMicroApp。
- 确认日志存在于源码：
  - 在 `loadMicroApp.ts` 搜到 666... 和 [qiankun][dev] 系列日志，说明源码里确实有输出。
- 排除构建剔除 console 的可能：
  - 检查 .fatherrc.cjs 没有做 console.* 移除，理论上不会被剥离。
- 强制重建依赖：
  - 先重建 @qiankunjs/ui-shared、@qiankunjs/react，确保其 dist 为最新。
  - 仍看不到日志，推断解析到了另一份 qiankun（非本地 dist/esm）。
- 关键修复一：webpack resolve.alias
  - 在示例的 `webpack.config.js` 中为以下包加别名：
    - qiankun → packages/qiankun/dist/esm
    - @qiankunjs/react → packages/ui-bindings/react/dist/esm
    - @qiankunjs/ui-shared → packages/ui-bindings/shared/dist/esm
  - 同时重建 qiankun 确保 dist/esm 最新，然后重启 dev server。
- 新问题：React hooks 报错（Cannot read properties of null (reading 'useState')）
  - 这是典型“页面存在两个 React 实例”的现象。由于我们通过 alias 把 @qiankunjs/react 指到本地构建的 ESM，它内部的模块解析可能又引入了另一份 react。
- 关键修复二：React 单例化（避免多 React）
  - 在示例的 `webpack.config.js` 再增加：
    - react → examples/main/node_modules/react
    - react-dom → examples/main/node_modules/react-dom
  - 重启 dev server 后，hooks 错误消失，同时可以看到 [qiankun][dev] 和 666... 日志。至此问题闭环。

   
四、根因总结

- 根因一：多入口/多路径导致“同一包的不同实例/不同构建”被加载
  - Vanilla 路径有本地直连，但 React 路径走 @qiankunjs/react → @qiankunjs/ui-shared → qiankun 的链路。没有 alias 时，webpack 对 “qiankun” 的解析容易落到 node_modules 的已发布版本或另一份 dist，而非我们本地最新构建，所以看不到新加的日志。
- 根因二：React 单例未强制，导致 hooks 崩溃
  - 在 monorepo + 本地 ESM 联调场景，若不显式 alias react 与 react-dom 到同一个拷贝，很容易出现多 React 实例，触发 useState 读取 null 的错误。
- 次要因素：对 workspace 的期望与 bundler 解析现实之间的偏差
  - workspace 让包彼此可见，但最终由示例的 webpack 决定解析到哪一份产物；不加 alias，就很可能不是你期望的本地 dist。


五、经验与最佳实践（强烈推荐）

- 对于 monorepo 中的 examples 工程：
  1. 1.
     在示例工程的 bundler（webpack/vite 等）里，对本地包统一进行 resolve.alias，指向对应的 packages/*/dist/esm 路径。至少保证以下包：
     - qiankun
     - @qiankunjs/react
     - @qiankunjs/ui-shared
  2. 2.
     React 项目务必再做 React 单例化 alias：
     - react → 示例自身的 node_modules/react
     - react-dom → 示例自身的 node_modules/react-dom
  3. 3.
     每次改动源码后，先构建 packages（保证 dist 是最新），再重启示例 dev server，避免缓存导致的旧包。
  4. 4.
     快速验证法：
     - 在源码里加入独特标记（如 666...），然后在浏览器控制台观察；或在 DevTools Source 面板中查找该标记，确认加载的是你期望的那份 dist 文件。
     - 使用两条触发路径（Vanilla 和 React）交叉验证，定位是否仅在某条链路未命中本地产物。
- 包配置建议：
  - 在各本地包内，确保对 react/react-dom 的 peerDependencies 要求清晰，并避免在构建时捆绑 React。
  - 在 examples 工程中记录 alias 样例，降低新同学搭建联调环境的门槛。


六、可复用的标准操作步骤（SOP）

- 步骤一：添加/确认 alias
  - 在 `webpack.config.js` 中确保有：
    - qiankun → packages/qiankun/dist/esm
    - @qiankunjs/react → packages/ui-bindings/react/dist/esm
    - @qiankunjs/ui-shared → packages/ui-bindings/shared/dist/esm
    - react、react-dom → 示例自身 node_modules
- 步骤二：构建本地包
  - pnpm -F qiankun run build
  - pnpm -F @qiankunjs/ui-shared run build
  - pnpm -F @qiankunjs/react run build
- 步骤三：重启 dev server
  - pnpm -F main run start:react（或对应命令）
- 步骤四：验证
  - 刷新 http://localhost:7099/ ，在控制台观察 [qiankun][dev] 与 666...。
  - 如仍异常，切 /multiple.html 路径对照，判断问题是否仅出现在 React 绑定链路。

 
七、这次变更涉及的关键文件（便于复盘）

- 示例工程配置：
  - `webpack.config.js`
  - `ReactRender.jsx`
  - `index.js`
- 绑定与内核：
  - `index.ts`
  - `loadMicroApp.ts`

 
八、结论

- 一开始没有看到日志，是因为 React 路径解析到了“不是我们本地最新构建”的 qiankun 副本；随后又因引入本地 ESM 导致出现多 React 实例而触发 hooks 报错。通过两轮关键修复（包别名强制走本地 dist + React 单例化），最终让示例稳定地消费本地产物并输出我们新增的调试日志。
- 经验上，monorepo 下 examples 工程与 workspace 的“默认解析”往往并不等价于“使用你想用的本地构建产物”。需要通过 alias 明确约束依赖解析路径，并确保 React 单例，才能顺畅进行联调与日志观测。
如果你愿意，我可以把这套 alias 约定整理成模板，方便其他示例（vite/vue 等）也快速接入，避免今后再踩同类坑。
